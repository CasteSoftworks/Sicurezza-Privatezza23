regole auree


								*POLITICHE DI ACCESSO*
Discretionary Acces Control (DAC)
- policy dettata dal proprietario della risorsa che decide come gestire gli  accessi (uso classico del pc)
Mandatory acces control (MAC)
- policy dettata dal sistema e decisa per tutti a priori (ambiente militare)
Role Based Acces Control (RBAC)
- a seconda della posizione e del ruolo la policy cambia (studenti, prof, sysadmin)

							
							*DEFINIRE UNA POLITICA DI SICUREZZA*
Matrice che associa un utente ai permessi per ogni risorsa

	------------------------
	| s\o | car | tas | ...
	------------------------
	| us1 |  x  |  -  | ...
	------------------------
	| us2 |  -  |  -  | ...
	------------------------
	| us3 |  x  |  x  | ...
	------------------------
	| ... | ... | ... | ...
	------------------------

Per tanti utenti non è gestibile --> COME POSSIAMO SFRUTTARE LE NOSTRE CONOSCENZE PER COMPRIMERE LA STRUTTURA DATI SENZA PERDERE PEZZI?

* divido le persone/utenti secondo il loro ruolo e posizione (se ho 50k utenti ma essi fanno parte di 5 gruppi da 10k -> anzichè avere 50k linee ne avrò 5) ACCES CONTROL LIST ACL
	------------------------
	| g\o | car | tas | ... 
	------------------------
	| gr1 |  x  |  x  | ...
	------------------------
	| gr2 |  -  |  -  | ...
	------------------------
	| ... | ... | ... | ...
	------------------------
	DA TENERE IN UN LUOGO SICURO PER TENERE SANA E SALVA LA POLICY - in Linux/Unix è contenuta nella I-NODE
							I-NODE -> struttura dati su HD in struttura chiamata I-NODE TABLE e contienete i metadati dei 									file 

							*CAPABILITY*
garantisce l'accesso attraverso dei TOKEN
tenuta nel KERNEL dell'OS per mantenere la protezione alta -> se qualcuno ne entra in possesso E' quella persona per il computer -> IMPORANTE
usato in Windows

Una banca tiene traccia di chi ha l'accesso alla cassetta di sicurezza, deve tenere al sicuro l'elenco -> ACCES CONTROL LIST
		AUTENTICAZIONE - la banca controlla chi entra
		PARTECIPAZIONE - la banca partecipa
		FALSIFICAZIONE - l'elenco è al sicuro
		DELEGAZIONE    - bisogna aggiunger euna entry ma è complesso                                                    
                ELIMINAZIONE   - è facile da rimuovere una entry

Io ho le chiavi della cassetta e posso decidere a chi darle, se voglio darle -> CAPABILITY
		AUTENTICAZIONE - la banca non controlla
		PARTECIPAZIONE - la banca non partecipa
		FALSIFICAZIONE - la chiave non è modificabile/copiabile
		DELEGAZIONE    - la chiave può essere data a chiunque
		ELIMINAZIONE   - è difficile farsi dare la chiave indietro

ACL E CAPABILITY HANNO PRO E CONTRO INVERSI
	--> ACL USATA DI PIU'

Il controllo di accesso è gestito dal Reference Monitor, un software che gesticìsce OGNI accesso e il cui funzionamento è ASSICURATO al 100%
					--> passaggio a livello
				 -------------------------------------------------
			:-) ---->|----> soggetto --> richiesta di accesso --      |
			         |                            ^            |      |
				 |                            | -deny-     |      |
				 |      policies -->reference monitor  <----      |
				 |                   ^            |               |
				 |                   | -grant-    ----> log       |
				 |                 object                         |---> PC
				 --------------------------------------------------

								*UTENTE SU UNIX*
Tutti coloro che sono presenti nel file /etc/passwd
				username:password:UID:GID:name:homedir:shell
				UID - User ID - numero 16b (per root è 0)
				GID - Group ID - numero 16b (per root è 0)
				password contiene x ora perché le password sono in /etc/shadow

				root ha controllo totale tolte:
				* LA CONOSCENZA delle password, ma può RISCRIVERLA
				* la RISCRITTURA dei file Read Only

				/etc/group conteiene groupname:password:GID:list_of_users

								*SOGGETTI*
processi distinti da PID -> generati da exec e fork -> oguno di loro ha un UID/GID reale e un UID/GID effettivo
effective UID è usato per gestire i processi

				          :real UID 1001  p1 <---------
				     :effective UID 800   |           |
							  | -comando- |
							  |          /
							  -----> P2 -        :real UID 1001
							        ^ |     :effective UID -800- --> 462 (esegue il processo con UID 462)
							        \-|<----\
								  ------>P3  :real UID 1001
								        :effective UID 462

Ad ogni oggetto possono accedere 3 tipi di utente
		* OWNER
		* GROUP
		* OTHER - qualunque altra cosa
Ogni soggetto può avere 3 operazioni --> si necessita di 3 bit
		* READ 		r
		* WRITE 	w
		* EXECUTE	x
				
				+ 7 = 111 = TUTTO
				+ 6 = 110 = solo read and write
				+ 5 = 101 = solo read e execute
				+ 4 = 100 = solo read
				+ 3 = 011 = solo write e execute
				+ 2 = 010 = solo write
				+ 1 = 001 = solo execute

chmod fa modificare i diritti di accesso
	sia con numeri sia con parole
		sudo chmod 0754 file.txt ->user tutto, group leggi esegui, other solo leggi

Ogni utente ha una sua directory di cui possiede tutti i permessi (rwx) e può modificare i permessi degli altri utenti per accedervi

GETFACL mostra nome,proprietario,gruppo e file ACL esistente
		getfacl nome_file_o_cartella

SETFACL modifica ACL
			setfacl -m u:nome_utente:xxx nome_file_o_cartella  - xxx può essere numero (7,6,5,..,1) o rwx,rw-,r--,...,--x
			setfacl -m g:nome_gruppo:xxx nome_file_o_cartella
			setfacl -m o

			setfacl -x u:.....                                 - rimuove i permessi

							*GREP*
Permette di cercare stringhe all'interno di file 
	grep stringa file
Ha opzioni principali
	-c conta le righe dove c'è match
	-i fa cercare la stringa indipendentemente dal case (hello, HELLO, HellO, heLLo,heLlo,...)
	-v stampa le linee
	-n stampa il numro di riga
Grep usa anche le espressioni regolari per fare le richerche
	[:::] dove ::: sono caratteri -> grep cercherà tutte li stringhe che contengono quei caratteri
					   ^ indica tutte tranne ciò che c'è dopo
	.       caratteri qualunque

							*FORMATI DI UN PROGRAMMA*
Sorgente -> dato in pasto al compilatore ---> UNA VOLTA dava il codice OGGETTO --> poi lo dava al LINKER---|
				|									   |--->ESEGUIBILE
				|									   |
				------------> ora fa sia compilazione sia linking assieme -----------------|


		foo.c ---> foo.o ---> foo.out <-- eseguito con un LOADER
		      comp       link

							*ELF*
Executable and Linkable Format ---> formato per eseguibili LINUX, videogiochi Sony, ....
Formato BINARIO 
Contiene il codice e TUTTE le info necessarie alla esecuzione
Composto da:
	* ELF Header
	* Sezioni
	* Segmenti


					-------------------------
					|	ELF Header      |
					-------------------------
					| program header table  |
					-------------------------
					| .text			|
					-------------------------
					| .rodata               |
					-------------------------
					| .bss                  |
					-------------------------
					| .plt		        |
					-------------------------
					| .got		        |
					-------------------------
					| .got.plt              |
					|------------------------
					|.symtab		|
					-------------------------

HEADER

readelf -h nome --> permette di leggere il file elf di un eseguibile per leggere le informazioni

e_entry: entry point in memoria centrale
e_phoff: offset della Program Header Table
e_shoff:
e_flags:
.....

SEZIONI
contiene tutte le info per il linking

readelf -S nome

sh_type:
sh_flags:
sh_addr:
sh_offset:
.......

SEGMENTI
dividono il file elf in spezzoni per .....

readelf -l nome

p_typr:
p_flags:
.......



		SORGENTE --> vi,vim,neovim,emacs
		ELF FILE --> readelf
		OBJECT   --> objdump


						*EXEC*
legge il path e cerca il file
lo carica in memoria
verifica se è un elf --> legge l'ELF Header --> legge il MAGIC NUMBER (e altro) e se è 7f 45 4c 46
se non lo è
	* se inizia con #! allor chiama l'interprete corretto
	* se è simile a /proc/sys/fs/binfmt_misc allora il kernel chiama il comando di interprete specifico
se lo è:
	* se è DYNAMIC-LINKED il kernel legge l'interprete specificato nell'ELF, lo chiama (attraverso il LINKER DINAMICO) 
	  per il file e gli da' controllo
	* se è STATIC-LINKED il kernel lo carica

	readelf -a cookie | grep interpreter fa vedere che interprete è usato
viene allocata la memoria virtuale per
	* il binario
	* le librerie
	* lo heap
	* lo stack
	* la memoria mappata specificatamente dal programma
	* il codice kernel nella prima metà della memoria

Dopo la compilazione il programma non entra subito in esecuzione ma fa dei passi precedenti e poi chiama il main del programma
						
						*ARGOMENTI*

IN C
	argc -> #argomenti
	argv -> array contenente gli argomenti
	envp -> variabili di ambiente

						*SYSTEM CALL*

Durante l'esecuzione il programma esegue delle Syscall per fare entrare l'os in modalità KERNEL e fargli eseguire ciò che è necessario.
Per vedere quali system call sono usate in un comando basta usare 
			strace comando -l
Su Linux ce ne sono 300 -> visibili usando "man 2 open"
Durante l'esecuzione l'SO comunica con i processi usando le SIGNAL
	syscall speciali che stoppano il processo
	hanno un numero assiociato
		9 --> chiamata SIGKILL -->il processo invoca ABORT su se stesso (fa SO se il processo non si ammazza)


Un processo muore in due modi:
	1: fa la exit();
	2: riceve SIGKILL

							*ALL PROCESSES MUST BE    R E A P E D*
						
Un processo dienta Zombie quando termina e deve essere rimosso dal padre con wait();
Quando viene rimosso si libera spazio per un altro processo
Se il padre muore prima i processi vengono rimossi da un DAEMON che cambia il loro PID a 1. Il processo padre con PID 1 fa periodicamente la wait();

							*PRIVILEDGE ESCALATION*
COMPLETE MEDIATION
Ogni tanto un processo necessita di più diritti di accesso di quelli che possiede --> Fa una scalata di privilegio, ma deve essere fatta in modo tale 											    che non si creino problemi
In UNIX si chiama Set-UID --> permette a utenti SENZA root che esegue un programma di usufruire dei diritti di accesso del programma quando lo usa
	ESEMPIO passwd
		
		$ ls -l /usr/bin/passwd
		-rwSr-xr-x 1 root root 41284 Sep 12 2012 /usr/bin/passwd

		passwd è di ROOT, ma quando lo eseguo DIVENTO io ROOT (finchè lo uso)

							*I DUE USER ID*

Ogni processo ha DUE UID:
	* Real UID --> UID del vero padrone del processo --> quelli su passwd
	* Effective UID --> identifica i privilegi di un processo --> l'accesso si basa su di esso
Di norma sono uguali. Quando Set-UID viene eseguito l'EUID cambia a quello di root (0) --> lo si può capire se nei permessi c'é una S (vedi sopra)

								*BASH*

.....

								*ASSEMBLY*

	LABEL OPCODE OPERAND COMMENT --> unico obbligatorio è opcode
	commento ; o # --> noi #	
	usiamo MASM
	
	dati salvabili in registri o variabili <---- in memoria
			  ^
			  |
			speciali in chip
			UNICI MANIPOLABILI
					

	byte B 			=      ~1/2B~   =	4b
	word			=	1B	=	8b
	double word		=	4B	=	16b
	quadruple word		=	8B	=	32b
	double quadruple word	=	16B	=	64b

	registri sia a 64b, che 32b, che 16b che 8b a seconda di quali bit voglio
		ESEMPIO
			rax = 64b
			eax = 32b
			ax  = 16b -> ah+al (higher e lower)
			al  = 8b
	
	LITTLE ENDIAN!!!!

	SOLO DUE TIPI DI DATO	
		* NUMERI --> notazione binaria
			+ 100 -> 0110 0100
		* CARATTERI --> UTF8 --> OGNUNO OCCUPA 1B
			+ 100 -> 00110001 00110000 00110000
				    1        0         0

	I DATI HANNO BISONO DI RISERVAMENTO DI SPAZIO IN MEMOORIA
		ESEMPIO
			buffer:		resb	64 #byte
			wordvar:	resw	1  #word
			realarray:	resq	10 #array

					db	0x55 ->85 numero O 'U'
					db	'hello'
		
	Per spostare da memoria a registri bisogna usare delle ADDRESSING MODES
		1 Accedere ai dati dai registri
		2 "	   "   "   da immediato
		3 "        "   "   da memoria
			a Modalità Diretta
			b "        Indiretta
				* Registrer addressing -> muove i dati da e in i registri --> mov rdx,rcx
					+ a registro
						mov rdx,rcx
					+ a immediato
						mov rax,100 --> NON COSI', è vago, bisogna specificare
						mov DWORD PTR rax,100 --> usa solo i primi 32b
				* Indirect Addressing --> voglio usare i puntatori --> [registro]
						mov rcx,[rax] --> metto in rcx il contenuto dell'indirizzo di memoria di rax
						   rax                              rcx
						--------                         --------
						| 1000-|------> memoria -------> | .... |
						--------        ad indirizzo     --------
						                1000
						
	INDIRIZZAMENTO DIRETTO è intuitivo ma poco flessibile
	"              INDIRETTO non è intuitivo ma è flessibile

							*LITTLE ENDIAN*

Dati salvati al contrario
	
	mov	eax,0xc001ca75	#carico diretto ----> | c0 | 01 | ca | 75 |
	mov	rcx,0x10000 	#65536
	mov	[rcx],eax	#carico eax all'INDIRIZZO 65536 in LITTLE ENDIAN --> | 75 | ca | 01 | c0 |
	mov	bh,[rcx]	#carico 0x75 che si trova a 65536 IN MEMORIA 

							*GIOCARE CON L'ASSEMBLY*

ESEMPIO:
	LOOP	add	rax,3
		jmp	LOOP

somma di 20 elementi di array
		xor	rax   #contatore
		xor	rbx   #somma
		lea	rcx,a #inzirizzo array
	sumloop:
		mov
		add
		....
	
LEA Load Effective Address -> carica in 1 l'ndirizzo della variabile 
	lea	rcx,buffer |_________> carico in rax il contenuto di buffer INDIRETTAMENTE
	mov	rax,[rcx]  |


add dest,src	#a=a+b
sub dest,src	#a=a-b
inc dest	#++
dec dest	#--
neg dest	#...
cmp dest,src    #confronta (b-a) e poi <0,>0,=0 modifica STATUS REGISTER a seconda

mul 	dest,src	#a=a*b SENZA segno
    	può essere uno solo, l'altro è supposto in rax
imul	dest,src	#a=a*b CON segno
div
idiv

CONTROLLO DI FLUSSO
opcode label
	controlla tra gli STATUS REGISTER della la cmp
je	#solo se destinazione=origine
jg	#solo se destinazione>origine
jge	#solo se destinazione>=origine
jl	#solo se destinazione<origine
jle	#solo se destinazione<=origine
jmp	#non condizionata

SYSCALL
usabili salvando sul registro rax il numero della syscall, negli altri registri inserisco gli argomenti e poi chiamo syscall
i ritorni sono eax
	* sys_read 	0	rdi=file_descriptor(0 stIn)	rsi=caratteri letti	rdx=numero caratteri da leggere
	* sys_write	1	rdi=file_descriptor(1 schermo)	rsi=caratteri stampare	rdx=numero caratteri da stampare

	leggere 100B da stdin a SP
	mov rdi,0
	mov rsi,rsp #in rsi valore dello SP --> se ho buffer uso lea rsi,buffer
	mov rdx,100
	mov rax,0
	syscall

								*SHELL CODE*

Codice in linguaggio macchina --> utile per sfruttare le vulnerabilità usando le INJECTION
										     |
										     v
				non sulla Harvard			durante l'esecuzione di un processo si
				       ^				inserisce del codice in più
				       |
Funziona perché nelle architetture di V.N. la memoria contiene SIA istruzioni SIA dati --> si possono aggiungere cose in mezzo

	PROGRAMMA DA COPIARE myFirstInjection.c
			--> può fare segmentation fault (causa sezione dell'IF)
			    uso gdb -q nome
			    la runno finchè non segmenta
			    faccio la info proc map
			    x/s $rip --> 0x7fffffffdb20:	"ciao"  		CONTENUTO della stringa COLPEVOLE
			    x/i $rip --> 0x7fffffffdb20:	movsxd 0x61(%rcx),%ebp	ISTRUZIONE COLPEVOLE


	objdump -M intel -d nomeEseg
		vedo la objdump
	
	objcopy --dump-section .text=RawFile nomeEseg
		copiare l'elf fuori dall'elf
	
	hexdump -C RawFile
		vedere la hexdump a byte

	shellCodeInjection --> fa aprire una shell a un processo aperto --> con diritti di ROOT
	shellCodeInjection.s --> shellCode
		poi uso objcopy per metterlo su un file con SOLO la parte di testo

	HO BISOGNO DI UN PAZIENTE 0 PER TESTARE PRIMA DI INIETTARE --> *CARRIER*
	carrier.c --> carrier --> tiene un pezzo di memoria di 1000B
				  legge e mette su questo pezzo RawFile
				  lo esegue

	gcc -o carrier carrier.c

	cat RawFile - | ./carrier

	ESERCIZIOOOOOOO
		fare una iniezione per aprire il file Flag in root usando myFirstInjection --> done and dusted


								*MEMORY ERROR EXPLOITS*
S M A S H I N G   the stack

Usata da Morris per l'Internet Worm

-citazione di Aleph One-
E' possibile corrompere lo stack con l'overflow di un array e causare un salto ad una routine casuale

	---------------------
	|    kernel space   |
	---------------------
	|     stack         | --> roba in main --> int a,b;
	---------------------
	|     heap          | --> roba in heap (malloc,...) --> int *ptr=(int *)malloc(2*sizeof(int));
	---------------------
	|     bss           | --> roba non inizializzata --> static int i;
	---------------------
	|     data          | --> roba inizializzata --> int x=2; (in globale)
	---------------------
	|     text          | --> programma vero e proprio
	---------------------

								*LO STACK*
LIFO
Usato O dal programmatore O dal compilatore
rispetta naturamente le chiamate di un programma
		|esempio
		------>	main					main -> callA -> callB -> callC
				callA					main     callA    callB
					callB					 main     callA
						callC					  main
I dati possono essere aggiunti in unità da multipli di 64b
La maggior parte delle CPU hanno istruzioni e registri specifici per la gestione dello STACK
		
		RUNTIME STACK
			SS 	stack segment
			RSP	stack pointer <--- punta all'ultima operazione che è occupata

		PUSH
			inserisce una quad word sullo stack sottraendo 8 da RSP e salvando il risultato in [RSP]
			push reg/imm
			      |
			      -------------------> sub	rsp, 8          RICORDA L'ESADECIMALEEEEEE
			      			   mov	[rsp], reg/imm

		POP
			legge una quad word da [RSP] e aggiunge 8 a RSP
			POP reg/imm
			      |
			      -------------------> mov	reg/mem, [RSP]
			      			   add	RSP, 8

		SCRIVERE UN PROGRAMMA ASSEMBLER CHE INVERTE IL CONTENUTO DI UNA STRINGA
			ESEMPIO
			INPUT: 	CACCA
			OUTPUT:	ACCAC

							*LO STACK E LE CHIAMATE DI FUNZIONE*

Lo stack contiene i function pointer --> si allocano sia le funzioni sia i parametri passati ad esse <-- l'insieme di queste si dice STACK FRAME

	ESEMPIO vedi foto
	---------
	|   jj  | | --> bar
	---------
	|   ii  | |
	--------- |
	| iiii  | |
	--------- | --> foo
	|  iii  | |
	--------- |
	|   ii  | |
	---------
	|   10  | | 
	--------- | --> main
	|   x   | |
	---------

Contiene inoltre gli INDIRIZZI DI RITORNO dalle funzioni (prima che ne vnga chiamata una salva si salva sullo stack l'indirizzo della istruzione successiva ala funzione attuale)
	CALL NOMESOTTOROUTINE --> push rip
				  jmp  nomesottoroutine
	
	RET 		      --> pop rip


							*PASSARE I PRAMETRI*
Fino a 6 argometi sui registri
Gli altri sullo stack  --> di norma lo fa il compilatore


							*USARE RBP*
Prima dell'inizio della funzione il compilatore inserisce due/tre istruzioni dette PROLOGO
				push 	rpb
				mov  	rbp,rsp
				(sub Local_bytes, %esp) --> opzionale (tiene spazio per va locali)

Prima del return il compilatore aggiunge tre istruzino dette EPILOGO
				movl	rsp,rbp
				pop	rbp
				ret

		A COSA SERVE IL PROLOGO?
		serve a fare in modo che RSP possa cambiare senza modificare RBP inizale prima che questo venga modificato dalla sotto-routine
		A COSA SERVE L'EPILOGO?
		serve a annullare il prologo riportando lo stack alla situzaione precedente alla chiamata

		USARE COOKIE.C per vincere --> 
			scambiare cookie e buf[80] (cookie in alto)
			gcc -fno-stack-protector -o cookie cookie.c --> -fno-stack-protector serve a disabilitare le protezioni MODERNE al buffer 
									overflow
			objdump -M intel -d cookie --> *PER CAPIRE QUANTO SPAZIO E' ALLOCATO a BUF*
			./cookie
			in input una dimensione adeguata di caratteri a caso e in fondo 0x41424344 (ABCD) IN LITTLE ENDIAN (DCBA)

	A CASA
	foto (cookie modificato con 0x01020305 invece di 0x41424344) --> basta copiare il metodo precedente cambiando la parte di appiccico finale

							*STRATEGIA DI ATTACCO*
INIETTARE:
	come le iniezioni in aula
		shell code scritto
GIA' PRONTO:


--> devo fare l'hijack del flusso di controllo
				FOTO/retHijack.c scopri quale xx e modifica +8 a +16/24/32 (scopri) e fai funzionare (value of x=13)
				--> FATTO vedi C/returnAddressHijack/rethijack.c --> +4 al primo e +16 al secondo fa saltare da c=function() a
										printf(...) senza passare per x=10
											|
											|
											v
										uso gdb con vari breakpoint per studiare l'evoluzione dello stack nei
										vari stadi e capire quanto devo spostare considerando che la printf
										in assembly occupa diverse linee di mov e una lea, mentre x=10 occupa
										una sola movl --> noi dobbiamo saltare alla istruzione subito dopo
												  skippando una mov post call e la movl stessa

COMANDI UTILI
	COMPILAZIONE
		gcc -fno-stack-protection -z execstack fileSorg -o eseguibile
	DIABILITARE ASLR
		echo 0 > /proc/sys/kernel/randomize_va_space
		sudo sysctl -k kernel.randomize_va_space=0
	ENABLE CORE DUMP
		unlimit -c unlimited
	VEDERE CORE DUMP
		gdb -q exectable core

NUOVO PROGRAMMA cookie ma con prima buf e poi cookie (come originale)
		ricorda che
			       RA
			       RBP					probabilmente come per esercizio precedente (retHijack) con studio di stack
			       buffer								^
			       cookie								|
												|
						sbufferare non va --> devo saltare l'if sbufferando fino a ra (con a ra l'indirizzo della print 
								      nell'if IN LITTLE ENDIAN) vedi script python in foto (buf+=.... con address
								      vero)



								*INJECTION CON CAMBIO DELLA RET*

Fare una iniezione di shell su un file SENZA debolezze (gravi, c'è una gets comunque) modificando la ret alla fine del main per saltare ad un indirizzo di stack dove abbiamo caricato il nostro codice.
vedi README in Injection/Lez2/ShellConRetMod per la procedura --> l'indirizzo può variare a seconda dello stato del PC in quel momento, ATTENZIONE

PER CASA --> injection di shell su un programma stile vittima ma con un buffer di 4 !!!

							*CONTROMISURE AI MEMORY ERROR*

LATO SVILUPPATORE:	Non usare funzioni vulnerabili tipo gets() e scanf() ma funzioni come strncpy,strncat,... che sono SICURE (la N)
								'------> NON far copiare più B di quanti devono
								'------> PROBLEMA PER SOFTWARE LEGACY (vecchio)
LATO SO:		Randomizzare il layout dell'address space --> ASLR
								'------> risolve per il software legacy su sistemi MODERNI
								'------> rende molto difficile trovare i RA
								'		'------> ci sono metodi per superare ma sono molto complessi
								'------> si può scoprire tramite programmino che stampa l'indirizzo in HEAP e STACK d
									 di due variabili
LATO COMPILATORE:	Implementare una Stack Guard --> disabilitata da -fno-stack-protector --> inventato da Chris Eagle
						'------> è un blocco nello stack di dimensione variabile e segreta --> serve a obbilgare alla modifica
													'	       quel pezzo
										 canary in inglese <----'		  '
										  '	'-> il canarino delle miniere	  '
					   esempio di canarino: 0x00dba000 <------'					  '
								'							  '--> se viene trovata una
								'--> 00 termina gets()					       modifica blocca la
								'--> a0 termina scanf()					       esecuzione
								'--> detto TERMINATOR								     '
														segna di errore di <-'
														stack smashing
LATO HARDWARE:		Non permettere l'esecuzione dallo Stack
(ma anche SW)				'
	'			'--> si contavviene legermente il principio di Von Neumann e si decide che lo stack NON può contenre codice
	'
	'--> -z execstack rimuove l'implementazione SW
	'--> su Windows implementato con DEP (Data Execution Prevention) su XP e server 2003 --> evita che il codice venga eseguito dallo stack e heap					'----> sia SW che HW

-----------------------------------------------------------------------------------------------------------------------------------------------------   __  __   _   _ __      ___   ___ ___ 
 |  \/  | /_\ | |\ \    / /_\ | _ \ __|
 | |\/| |/ _ \| |_\ \/\/ / _ \|   / _| 
 |_|  |_/_/ \_\____\_/\_/_/ \_\_|_\___|
                                       

NIST 800-83 --> un programma diffuso su un sistema, di norma di nascosto, con l'intento di compromettere la confidenzialità, integrità o disponibilit
		del sistema vittima

Diversi tipi --> Worm, Trojan, Backdoor, Keylogger, Logic Bomb, ...

							*COMPOSIZIONDE DI UN MALWARE*
	
							--------------------------
							| Propagazione | Payload | --> COSA FA
							--------------------------
								'
								'---> COME SI MUOVE

							*CLASSIFICAZIONE*

Possono essere divisi in diversi modi
			'
			'--------------------> Come si diffonde				|----> MODO 1
			'--------------------> Cosa fanno una volta ce hanno infettato  |
			'
			'--------------------> Se hanno bisogno di un sistema ospite	|
			'		       VIRUS					|
			'--------------------> Se sono "autonomi" (hanno tutto ciò che	|
			'		       può servire al loro funzionamento)	|
			'		       WORM, TROJAN, BOTS			|----> MODO 2
			'--------------------> Se si replicano				|
			'		       WORM					|
			'--------------------> Se non si replicano			|
					       TROJAN					|

					       		*PROLIFERAZIONE*

Infezione di altro software
Sfruttamento di un exploit
Social Engeneering per rimuovere feature di sicurezza

							*AZIONI DEL PAYLOAD*

Nascondersi
Compromettere file
Rubare informazioni
Distruggere la macchina

							*KIT DI ATTACCO*

All'inizio dovevano essere precisissimi e specifici
Poi sono nati dei META-MALWARE --> enerano il codice malevolo a partire da poche informazioni 
		'
		'----> Zeus e Angler
		'----> Comprabili da soggetti poco raccomandabili
							
							*CHI LO FA*

* Chi ha motivazioni politiche				--> ?
* Criminali 						--> pochi
* Organizzazioni Criminali 				--> mafia?
* Organizzazioni che vendono al miglior offerente	--> data brokers
* Intelligence						--> CIA, NSA, FSB, Mossad, ...
* Smanettoni						--> rarizzimi ormai

Grossi movimenti di soldi, molto difficile ormai

							*ADVANCED PERSISTEN THREAT*

Avanzato e persistente, come da nome
	'--------------> usato dall'intelligence     |
	'--------------> come prima cosa si nasconde |---> esempio SOLAR WINDS (1k anni umani di sviluppo, sgamato dopo 10 mesi dopo un controllo
	'--------------> mandato a bersagli PRECISI  |     casuale sul traffico di rete)

Tecniche specifiche di attacco e di mimesi

								*VIRUS*

Programmi che INFETTANO un altro programma --> appiccicandosi al programma ospite (intero alla fine/inizio o a pezzi in giro)
		'
		'-----> sposta l'entry point al pezzo di virus e poi all'inizio dell'ospite --> file ELF
		'-----> può fare tutto ciò che può fare l'ospite --> se root sono guai
					'---> può provare a fare Priviledge Escalation


				--------
				 HEADER
				--------
				PROGRAM
				--------



COME INFETTANO 			--> infection vector
QUANDO SI ATTIVANO		--> trigger 
COSA FANNO			--> payload

FASI
		IDLE/DORMIENTE --> non fa nulla finchè non c'è un trigger --> non sempre presente
		ATTIVAZIONE    --> il trigger avviene
			PROPAGAZIONE --> si riproduce
			ESECUZIONE   --> esegue il payload

MACRO VIRUS
	Si attaccano a file vari (PDF, DOCX, immagini, ...) che sono scritti in diversi linguaggi --> Office in VisualBasic
	Il virus è scritto nello stesso linguaggio ed è contenuto in questi file
	Più semplici da scrivere e indipendenti dalla piattaforma

	MELISSA --> primo macro virus 
	  '---> infettava tutti i futuri documenti aperti con office
	  '---> mandava se stesso a 50 indirizzi su Outlook
	  '---> si segnava sulla macchina
	  '---> si attivava se il minuto era = all'ora

Una volta venivano identificati dalla SIGNATURE --> stringa UNIVOCA nel codice, quando trovata veniva aggiunta alla lista
					'-->ORA NON PIU' --> sono stati sviluppati VIRUS CIFRATI
									|
									|
									v
					prima c'è il virus criptato POI la routine di decriptazione e encriptazione
									|
									v
					sgamabile attarverso la routine di decrptazione e encriptazione --> la signature diventa la routine
									|
									v
					evitabile attraverso la modifica (ogni volta) della routine --> la signature cambiano ogni volta
									| '--> VIRUS POLIMORFICO
									v
					Kaspersky capisce che POST decriptazione il virus è in CHIARO --> lo si becca adesso in una VM che
									|				  l'antivirus apre apposta
									|				   '--> ANALISI STATICA
									v
					evitabile facendo in modo che il virus si modifichi da solo di generazione in generazione
									| '--> VIRUS METAMORFICO
									v
					sgamabile in esecuzione per vedere cosa fa --> se fa cose sospette lo flaggo
					                                  '--> ANALISI DINAMICA

CLASSIFICAZIONE
	DIPENDENTE DAL BERASGLIO
		BOOT SECTOR --> zona dove c'è il kernel e che lo carica --> infetta OGNI volta che viene acceso/riavviato
		ESEGUIBILI  --> si appiccica all'eseguibile --> infetta al lancio
		DOCUMENTI   --> "    "       a un file --> infetta all'apertura
		SPARSO      --> mix di quelli sopra
	DIPENDENTE DALLA MIMESI
	???

								*WORM*

Malware AUTONOMO
Sfrutto problemi esterni (exploit) per farlo eseguire/proliferare --> ad esempio il SERVIZIO DI RETE
						'				'---> ascolta il traffico delle porte e risponde di conseguenza
						'--> spesso si manda in giro sulla rete A CASO
								|
								|
								v
						può farlo attraverso svariati modi
										'---> email
										'---> login
										'---> app di messaggistica

In generale un Worm attacca una macchina (che ha un certo IP) e da qui si propaga in diversi modi
										'---> cerca sistemi collegati
										'---> genera un IP a caso (o semi caso)

La crescita è inizialmente lenta, poi veloce e di nuovo lento a ciclo
	 
	|                   .
	|                .
	|              .
	|            : 
	|           :
	|          .
	|        .
	|      .
	|    .
	|..::_______________

Il primo Worm è INTERNET WORM, altri sono MELISSA, CODE RED, STUXNET

								*RAMSONWARE*

Criminalità organizzata, chiede un ricatto per riavere i dati, che vengono criptate fino al pagamento (o anche oltre)
			'---> scoperti dopo segnalazioni da utenti O sonde automatiche

Ad esempio WANNACRY, che chiedeva 300$ in BTC per dare la chiave di cifratura
			'
			'----> fermato perché pingava un sito web e se questo non rispondeva si attivava <-- KILL SWITCH

								*MOBILE CODE WORMS*

Malware eseguibile da piattaforme diverse
Spesso scritto in Java/Javascript/VBScript

Il primo fu Cabir nel 2004, lo seguirono Lasco e CommWarrior nel 2005
Usavano Bluetooth e MMS, ORA usano i Marketplace (specialmente su Android)

								*DRIVE-BY-DOWNLOADS*

Viene inividuata una vulnerabilità su un Browser, si fa scaricare (al momento della connessione ad un server) un documento che si autoesegue e sfrutta
la vulnerabilità del browser per replicarsi 

								*CLICK-JACKING*

Banner che spingono al click per infettare ("HAI VINTO UN IPHONE", "ALLARGA IL PENE", ...) e fare cose (dall'innocuo cancellarti le mail a cose più 
serie)

								*SOCIAL ENGENEERING*

Fregare l'untente convincendolo ad aiutare inconsapevolmente la sua infezione --> tipo gli scammer
								
								*COSA PUO' FARE IL PAYLOAD*

DISTRUZIONE DEL SISTEMA
	Stuxnet --> rompeva le centrifughe
	Chernobyl Virus --> cancella il boot sector (Win 95/98)

PROPAGAZIONE DI WORM
	Internet Worms --> vedi sopra

RANSOMWARE --> dall'arrivo delle criptovalute sono popolarissimi e efficaci
	Wannacry --> vedi sopra

CREAZIONE DI BOTNET
	Prendere il controllo del sistema e usarlo per i miei scopi --> un migliaio conosciute
				'--> DDoS
				'--> Keylogger
				'--> Cryptominer
				'--> invio di malware
				'--> spam
				'--> controllo del traffico delle informazioni --> questionari, statistiche, ...
				'
				'--> SCONFIGGIBILE "tagliando la testa" al principale, ma è difficile e poco utile --> facilmente sostituito
										'
										'----> la REMOTE CONTROL FACILITY/COMMAND&CONTROL Network
											'-> il server per il nostro
SPYWARE
	Controlla ogni azione che avviene sulla macchina --> spesso su cellulari --> jailbreak e ottiene i diritti di root
				'--> intercetta telefonate             |
				'--> intercetta messaggi               |---> e le invia a chi di dovere
				'--> controlla contatti		       |
				'--> tiene sotto controllo le immagini |
	Molto più facilmente creabili per Android ----,----> funzionava ance su Apple
	Il più famoso era PEGASUS della NSO, usato spesso dalle agenzie d'intelligence --> ora deprecato UFFICIALMENTE ;-)

PHISHING
	...

BACKDOOR
	Punto di ingresso nascosto nella macchina ad uso futuro creato DURANTE la creazione O aggiunto in seguito -> ad esempio il servizio di rete
	Usato anche per scopi legittimi (debugging)

ROOTKIT
	Una serie di programmi che vengono installati per dare all'attaccante i permessi di root
	Di varia natura
		PERSISTENTI --> a ogni boot in memoria
		AD ATTIVAZIONE --> si attivano al lancio del programma ospite e allo spegnimento si annulla
		USER MODE --> meno pericoloso
		KERNEL MODEc --> più pericoloso
		VM BASED --> sostituiscono il sistema con una esatta copia in VM --> "letale"
	Ad esempio cambiano le syscall
	MOLTO COMPLESSO

							*COME E' STATO CONTRASTATO NEGLI ANNI*

Idealmente la difesa da una QUALUNQUE minaccia è divisa in tre fasi
	PREVENZIONE
	IDENTIFICAZIONE
	RIMOZIONE

In IT Security la difesa si dvide in
	POLICY --> linee guida per l'uso (solo gli amministratori possono fare X, ...)
	AWARENESS --> rendere consapevoli gli utenti (attenzione a leggere l'indirizzo mail del mittente, ...)
	VULNERABILITY MITIGATION --> ridurre al minimo le vulnerabilità
	THREAT MITIGATION --> ridurre le minacce al sistema
	DETECTION --> sgamare la minaccia
	REMOVAL --> eliminare la minaccia


								*GLI ANTIVIRUS*

Antivirus
' '--->4 GENERAZIONI
' '		1a --> controllo della signature --> funzionava solo a "infezione nota"  (vedi sopra per dettagli)
' '		2a --> congelava il SW sulla macchina e creare una signature per CIASCUN programma		--> INTEGRITY CHECKING
' '									'					|
' '									'-> se il software cambiava essa cambiava -> allarme di potenziale minaccia
' '		3a --> esecuzione controllata del malware per analisi (vedi sopra per dettagli)
' '		4a --> simulazione e confronto attraverso Machine Learning --> non sono SOLO passivi, ma anche ATTIVI <-- Detection in semi real time
' '											'
' '											'---> possono creare FALSI POSITIVI
' ' 
' '--->Funzionano o a SIGNATURE BASED o a BEHAVIOUR BASED --> in realtà in entrambi ormai perché gira tutt'ora il malware vecchio
' '	'-> stringa univoca   '-> a seconda delle syscall (tra le altre cose)
' '
' '							*LE SIGNATURE*
' '
' '--->Segreto industriale dei produttori --> qui spiegato la minor o miglior difesa --> dati raccolti O da sensori sulla rete O sulle macchine degli
' '     utenti
' '													'--> raccolti e analizzati in automatico
' '--->Per ridurre la concorrenza esiste il CME --> Common Signature Enumeration
' '						'---> di MITRE e finanziato dagli USA
' '						'---> mira a dare un identificatore unico e comune a ogni malware
' '
' '--->Virus Total, di Google, analizza i file degli utenti che glielo forniscono usando diversi antivirus ONLINE e pseudo-gratuitamente
v
ORA SONO CHIAMATI EDR --> Endpoint Detection & Recovery				    |
	Analizzzando in automatico con Machine Learning, AI e Threat Intelligence   |--> Next Generation Antivirus
									'-> analisi |

							*ABRA WORM*

Presentato a Purdue Uni
Worm --> infetta una e tenta di infettare altre
In particolare cerca di rubare dei file

	SCHEMA				   ssh           ssh
				attaccante ---> INTERNET ---> vittima
					^		      | |
					'----------------------	|
								v
							       server

Prova ad usare ssh per connettersi con una bruteforce tra le password nel suo dizionario
Deve rubare dei file
	'-->TUTTI quelli che contengono la parola "abracadara"
	'-->fa ls e grep per trovare i file
Esfiltra il codice (sia sul PC per debug, sia sul server) usando SCP (copia tramite ssh)
Tenta di infettare le altre macchine
	'--> copia se stesso nelle macchine infettate e da loro tenta di trovare altri

Tutto su doker (VM) --> vedi guida qui:  https://git.laser.di.unimi.it/teozoia/abraworm
	VITTIMA usa la 2222 sulla 12345
	ATTACCANTE usa la 2222 sulla 22
eventualmente eliminare con 
	rm -r ssh* --> per eliminare i file ssh
su un terminale
	sudo docker-compose up --force-recreate

su un altro terminale
	cd worm
	python3 AbraWorm.py

	FARE RAMSON WARE con libreria crypto?
